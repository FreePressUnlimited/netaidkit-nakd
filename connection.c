#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <linux/un.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/socket.h>
#include "connection.h"
#include "message.h"
#include "log.h"

int nakd_handle_connection(int sock) {
    struct sockaddr_un client_addr;
    socklen_t client_len = sizeof(struct sockaddr_un);
    char message_buf[MAX_MSG_LEN];
    int nb_read = 0, nb_sent;
    json_tokener *jtok;
    int nb_parse, parse_offset;
    json_object *jmsg = NULL;
    json_object *jresponse = NULL;
    const char *jrstr;
    int nb_resp;
    enum json_tokener_error jerr;
    int rval = 0;

    jtok = json_tokener_new();

    /* TODO: GRAB CREDENTIALS OF CONNECTING PROCESS */

    for (;;) {
        do {
            if (jerr == json_tokener_continue) {
                nakd_log(L_DEBUG, "Parsing incoming message, offset: %d",
                                                      jtok->char_offset);
                nakd_log(L_DEBUG, "jerr == json_tokener_continue, "
                                              "reading some more");
            }

            /* If there was another JSON string in the middle of the buffer,
             * start with an offset and don't call recvfrom() just yet.
             */
            parse_offset = jtok->char_offset < nb_read ? jtok->char_offset : 0;
            if (!parse_offset) {
                if ((nb_read = recvfrom(sock, message_buf, MAX_MSG_LEN, 0,
                          (struct sockaddr *) &client_addr, &client_len)) < 0) { 
                    nakd_log(L_DEBUG, "recvfrom() < 0, closing connection (%s)",
                                                             strerror(nb_read));
                    goto ret;
                } else if (!nb_read) {
                    /* Handle orderly shutdown. */
                    nakd_log(L_DEBUG, "Client hung up.");
                    goto ret;
                }
                nakd_log(L_DEBUG, "Read %d bytes.", nb_read);

                /* remaining bytes to parse */
                nb_parse = nb_read;
            } else {
                nb_parse = nb_read - jtok->char_offset;
            }

            /* partial JSON strings are stored in tokener context */
            jmsg = json_tokener_parse_ex(jtok, message_buf + parse_offset,
                                                                nb_parse);
        } while ((jerr = json_tokener_get_error(jtok)) == json_tokener_continue);

        if (jerr == json_tokener_success) {
            nakd_log(L_DEBUG, "Parsed a complete message of %d bytes.",
                                                    jtok->char_offset);

            /* doesn't allocate memory */
            const char *jmsg_string = json_object_to_json_string(jmsg);
            nakd_log(L_DEBUG, "Got message: %s", jmsg_string);

            jresponse = nakd_handle_message(jmsg);
            jrstr = json_object_get_string(jresponse);

            while (nb_resp = strlen(jrstr)) {
                nb_sent = sendto(sock, jrstr, nb_resp, 0,
                        (struct sockaddr *) &client_addr,
                                             client_len);
                if (nb_sent < 0) {
                    nakd_log(L_NOTICE,
                        "Couldn't send response, closing connection.");
                    rval = 1;
                    goto ret;
                }
                jrstr += nb_sent;
            }

            nakd_log(L_DEBUG, "Response sent: %s",
                json_object_to_json_string(jresponse));
            json_object_put(jresponse), jresponse = NULL;
        } else {
            nakd_log(L_NOTICE, "Couldn't parse client JSON message: %s."
                                                 " Closing connection.",
                                         json_tokener_error_desc(jerr));
            rval = 1;
            goto ret;
        }

        json_object_put(jmsg), jmsg = NULL;
    }

ret:
    /* NULL-safe functions */
    json_object_put(jresponse);
    json_object_put(jmsg);
    json_tokener_free(jtok);
    return rval;
}

